// Inicialização da árvore de arquivos 
$(function(){
  var selNodes;
  $("#tree").dynatree({
    minExpandLevel: 2,
    checkbox: true,
    selectMode: 3,
    children: treeData,
    onSelect: function(select, node) {
      selNodes = node.tree.getSelectedNodes();
    },
    onClick: function(node, event) {
      if ( event.shiftKey ) {
        editNode(node);
        return false;
      }
      if ( node.getEventTargetType(event) == "title" )
        node.toggleSelect();
    },
    onDblClick: function(node, event) {
      editNode(node);
      return false;
    },
    onKeydown: function(node, event) {
      switch( event.which ) {
        case 113: // [F2]
          editNode(node);
          return false;
        case 32: // barra
          node.toggleSelect();
          return false;
        case 46: // [delete]
          deleteNodes([node]);
      }
    },

    dnd: {
      onDragStart: function(node) {
        /** This function MUST be defined to enable dragging for the tree.
         *  Return false to cancel dragging of node. */
        return true;
      },
      onDragStop: function(node) {
        // This function is optional.
        // SALVAR ALTERAÇÃO
    },

    autoExpandMS: 1000,
    preventVoidMoves: true, // Prevent dropping nodes 'before self', etc.

    onDragEnter: function(node, sourceNode) {
      /** sourceNode may be null for non-dynatree droppables.
       *  Return false to disallow dropping on node. In this case
       *  onDragOver and onDragLeave are not called.
       *  Return 'over', 'before, or 'after' to force a hitMode.
       *  Return ['before', 'after'] to restrict available hitModes.
       *  Any other return value will calc the hitMode from the cursor position.
       */
      return true;
    },
    onDragOver: function(node, sourceNode, hitMode) {
      /** Return false to disallow dropping this node. **/
      if(node.isDescendantOf(sourceNode)){ // Impede que o "pai" seja arrastado para o próprio filho
        return false;
      }
      // Prohibit creating childs in non-folders (only sorting allowed)
      if( !node.data.isFolder && hitMode === "over" ){
        return "after";
      }
    },
    onDrop: function(node, sourceNode, hitMode, ui, draggable) {
      /** This function MUST be defined to enable dropping of items on the tree. */
      if(node.data.isFolder) // se for pasta
        sourceNode.move(node, hitMode); // move para o nó
      else // se tiver
        sourceNode.move(node.parent, hitMode); // move para o pai do nó (a pasta a qual pertence)
      // expand the drop target
      // sourceNode.expand(true);
    },
    onDragLeave: function(node, sourceNode) {
      /** Always called if onDragEnter was called. */
    }
  }

  });

  // criar novo folder com texto padrao e foco para editar
  $("#btn-new-folder").click(function() {
    var node = $("#tree").dynatree("getActiveNode");
    var number = 0; // MUDAR NOME
    var new_folder_name = '<%= I18n.t(:new_folder, scope: [:lessons, :files]) %>';

    if (node != null && node.data.isFolder) {

      while(validName(node, new_folder_name) == false){
        number = number+1;
        new_folder_name = '<%= I18n.t(:new_folder, scope: [:lessons, :files]) %>'+number;
      }

      node.addChild({ title: new_folder_name, isFolder: true, focus: true });
      node_path = getPath(node);

      newFolder(new_folder_name, node_path);

    }

    return false;
  });

  $("#btn-deselect-all").click(function(){
    $("#tree").dynatree("getRoot").visit(function(node) {
      node.select(false);
    });
    return false;
  });

  $("#btn-select-all").click(function(){
    $("#tree").dynatree("getRoot").visit(function(node) {
      node.select(true);
    });
    return false;
  });

  $("#btn-remove-node").click(function(){
    deleteNodes(selNodes); // deleta os nós que foram selecionados
  });

  // $("#btn-clean-lesson").click(function(){
  //   deleteNodes($("#tree").dynatree("getRoot").childList); // deleta todos os nós, exceto o raiz
  // });

});

function editNode(node) {
  if (node.data.key == '_2') // raiz visivel
    return false;

  var prevTitle = node.data.title,
  tree = node.tree;
  // Disable dynatree mouse- and key handling
  tree.$widget.unbind();
  // Replace node with <input>
  $(".dynatree-title", node.span).html("<input id='editNode' value='" + prevTitle + "'>");

  // Focus <input> and bind keyboard handler
  $("input#editNode")
    .focus()
    .keydown(function(event) {
      switch( event.which ) {
        case 27: // [esc]
          // discard changes on [esc]
          $("input#editNode").val(prevTitle);
          $(this).blur();
          break;
        case 13: // [enter]
          // simulate blur to accept new value
          $(this).blur();

          break;
      }
    }).blur(function(event){
      // Accept new value, when user leaves <input>
      var title = $("input#editNode").val();
      node.setTitle(title);
      // Re-enable mouse and keyboard handlling
      tree.$widget.bind();
      node.focus();
    });
}

// Função para excluir nós selecionados ou todos
function deleteNodes(nodes){
  if (confirm("certeza?")){
    var i = 0;
    if(nodes[0].data.key != "_2"){ // remover selecionados
      for (i; i < nodes.length; i++){
        if (nodes[i].li != null && nodes[i].data.key != '_2'){
          nodes[i].remove();
          saveDeletion(nodes[i]);
        }
      }
    }else{ // remover todos exceto raiz
      
    }
    
  }else
    return false;
}

function saveDeletion(node){
  url       = $("#remove_path").attr("value");
  node_path = getPath(node);

  $.ajax({
    type: 'GET',
    url: url,
    data: {
      "path": node_path
    },
    error: function(data) {
      // erro
    }
  });
}

// Retorna o caminho em que o nó se encontra
function getPath(node){
  var path = []; 
  path.unshift(node.data.title);
  node.visitParents(function(node){ 
    if(node.parent && node.data.key != "_2"){ 
      path.unshift(node.data.title); 
    } 
  }); 
  return "/" + path.join("/"); 
}

// Verifica se o nome do nó é um nome válido
function validName(node, name){
  var unique_name = true;
  node.visit(function(childNode){ // varre todos os filhos do nó pai
    if(childNode.data.title == name) // verifica se nome escolhido já existe
      unique_name = false;
  });
  return unique_name;
}

// Cria pasta
function newFolder(name, path){
  url = $("#btn-new-folder").attr("value");

  $.ajax({
    type: 'POST',
    url: url,
    data: {
      "path": path,
      "folder_name": name
    },
    error: function(data) {
      // erro
    }
  });
}